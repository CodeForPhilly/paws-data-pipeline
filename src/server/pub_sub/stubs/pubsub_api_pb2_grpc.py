# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from pub_sub.stubs import pubsub_api_pb2 as pubsub__api__pb2


class PubSubStub(object):
    """
    The Pub/Sub API provides a single interface for publishing and subscribing to platform events, including real-time
    event monitoring events, and change data capture events. The Pub/Sub API is a gRPC API that is based on HTTP/2.

    A session token is needed to authenticate. Any of the Salesforce supported
    OAuth flows can be used to obtain a session token:
    https://help.salesforce.com/articleView?id=sf.remoteaccess_oauth_flows.htm&type=5

    For each RPC, a client needs to pass authentication information
    as metadata headers (https://www.grpc.io/docs/guides/concepts/#metadata) with their method call.

    For Salesforce session token authentication, use:
    accesstoken : access token
    instanceurl : Salesforce instance URL
    tenantid : tenant/org id of the client

    StatusException is thrown in case of response failure for any request.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Subscribe = channel.stream_stream(
                '/eventbus.v1.PubSub/Subscribe',
                request_serializer=pubsub__api__pb2.FetchRequest.SerializeToString,
                response_deserializer=pubsub__api__pb2.FetchResponse.FromString,
                )
        self.GetSchema = channel.unary_unary(
                '/eventbus.v1.PubSub/GetSchema',
                request_serializer=pubsub__api__pb2.SchemaRequest.SerializeToString,
                response_deserializer=pubsub__api__pb2.SchemaInfo.FromString,
                )
        self.GetTopic = channel.unary_unary(
                '/eventbus.v1.PubSub/GetTopic',
                request_serializer=pubsub__api__pb2.TopicRequest.SerializeToString,
                response_deserializer=pubsub__api__pb2.TopicInfo.FromString,
                )
        self.Publish = channel.unary_unary(
                '/eventbus.v1.PubSub/Publish',
                request_serializer=pubsub__api__pb2.PublishRequest.SerializeToString,
                response_deserializer=pubsub__api__pb2.PublishResponse.FromString,
                )
        self.PublishStream = channel.stream_stream(
                '/eventbus.v1.PubSub/PublishStream',
                request_serializer=pubsub__api__pb2.PublishRequest.SerializeToString,
                response_deserializer=pubsub__api__pb2.PublishResponse.FromString,
                )


class PubSubServicer(object):
    """
    The Pub/Sub API provides a single interface for publishing and subscribing to platform events, including real-time
    event monitoring events, and change data capture events. The Pub/Sub API is a gRPC API that is based on HTTP/2.

    A session token is needed to authenticate. Any of the Salesforce supported
    OAuth flows can be used to obtain a session token:
    https://help.salesforce.com/articleView?id=sf.remoteaccess_oauth_flows.htm&type=5

    For each RPC, a client needs to pass authentication information
    as metadata headers (https://www.grpc.io/docs/guides/concepts/#metadata) with their method call.

    For Salesforce session token authentication, use:
    accesstoken : access token
    instanceurl : Salesforce instance URL
    tenantid : tenant/org id of the client

    StatusException is thrown in case of response failure for any request.
    """

    def Subscribe(self, request_iterator, context):
        """
        Bidirectional streaming RPC to subscribe to a Topic. The subscription is pull-based. A client can request
        for more events as it consumes events. This enables a client to handle flow control based on the client's processing speed.

        Typical flow:
        1. Client requests for X number of events via FetchRequest.
        2. Server receives request and delivers events until X events are delivered to the client via one or more FetchResponse messages.
        3. Client consumes the FetchResponse messages as they come.
        4. Client issues new FetchRequest for Y more number of events. This request can
        come before the server has delivered the earlier requested X number of events
        so the client gets a continuous stream of events if any.

        If a client requests more events before the server finishes the last
        requested amount, the server appends the new amount to the current amount of
        events it still needs to fetch and deliver.

        A client can subscribe at any point in the stream by providing a replay option in the first FetchRequest.
        The replay option is honored for the first FetchRequest received from a client. Any subsequent FetchRequests with a
        new replay option are ignored. A client needs to call the Subscribe RPC again to restart the subscription
        at a new point in the stream.

        The first FetchRequest of the stream identifies the topic to subscribe to.
        If any subsequent FetchRequest provides topic_name, it must match what
        was provided in the first FetchRequest; otherwise, the RPC returns an error
        with INVALID_ARGUMENT status.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetSchema(self, request, context):
        """Get the event schema for a topic based on a schema ID.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetTopic(self, request, context):
        """
        Get the topic Information related to the specified topic.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Publish(self, request, context):
        """
        Send a publish request to synchronously publish events to a topic.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PublishStream(self, request_iterator, context):
        """
        Bidirectional Streaming RPC to publish events to the event bus.
        PublishRequest contains the batch of events to publish.

        The first PublishRequest of the stream identifies the topic to publish on.
        If any subsequent PublishRequest provides topic_name, it must match what
        was provided in the first PublishRequest; otherwise, the RPC returns an error
        with INVALID_ARGUMENT status.

        The server returns a PublishResponse for each PublishRequest when publish is
        complete for the batch. A client does not have to wait for a PublishResponse
        before sending a new PublishRequest, i.e. multiple publish batches can be queued
        up, which allows for higher publish rate as a client can asynchronously
        publish more events while publishes are still in flight on the server side.

        PublishResponse holds a PublishResult for each event published that indicates success
        or failure of the publish. A client can then retry the publish as needed before sending
        more PublishRequests for new events to publish.

        A client must send a valid publish request with one or more events every 70 seconds to hold on to the stream.
        Otherwise, the server closes the stream and notifies the client. Once the client is notified of the stream closure,
        it must make a new PublishStream call to resume publishing.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_PubSubServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Subscribe': grpc.stream_stream_rpc_method_handler(
                    servicer.Subscribe,
                    request_deserializer=pubsub__api__pb2.FetchRequest.FromString,
                    response_serializer=pubsub__api__pb2.FetchResponse.SerializeToString,
            ),
            'GetSchema': grpc.unary_unary_rpc_method_handler(
                    servicer.GetSchema,
                    request_deserializer=pubsub__api__pb2.SchemaRequest.FromString,
                    response_serializer=pubsub__api__pb2.SchemaInfo.SerializeToString,
            ),
            'GetTopic': grpc.unary_unary_rpc_method_handler(
                    servicer.GetTopic,
                    request_deserializer=pubsub__api__pb2.TopicRequest.FromString,
                    response_serializer=pubsub__api__pb2.TopicInfo.SerializeToString,
            ),
            'Publish': grpc.unary_unary_rpc_method_handler(
                    servicer.Publish,
                    request_deserializer=pubsub__api__pb2.PublishRequest.FromString,
                    response_serializer=pubsub__api__pb2.PublishResponse.SerializeToString,
            ),
            'PublishStream': grpc.stream_stream_rpc_method_handler(
                    servicer.PublishStream,
                    request_deserializer=pubsub__api__pb2.PublishRequest.FromString,
                    response_serializer=pubsub__api__pb2.PublishResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'eventbus.v1.PubSub', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class PubSub(object):
    """
    The Pub/Sub API provides a single interface for publishing and subscribing to platform events, including real-time
    event monitoring events, and change data capture events. The Pub/Sub API is a gRPC API that is based on HTTP/2.

    A session token is needed to authenticate. Any of the Salesforce supported
    OAuth flows can be used to obtain a session token:
    https://help.salesforce.com/articleView?id=sf.remoteaccess_oauth_flows.htm&type=5

    For each RPC, a client needs to pass authentication information
    as metadata headers (https://www.grpc.io/docs/guides/concepts/#metadata) with their method call.

    For Salesforce session token authentication, use:
    accesstoken : access token
    instanceurl : Salesforce instance URL
    tenantid : tenant/org id of the client

    StatusException is thrown in case of response failure for any request.
    """

    @staticmethod
    def Subscribe(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/eventbus.v1.PubSub/Subscribe',
            pubsub__api__pb2.FetchRequest.SerializeToString,
            pubsub__api__pb2.FetchResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetSchema(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/eventbus.v1.PubSub/GetSchema',
            pubsub__api__pb2.SchemaRequest.SerializeToString,
            pubsub__api__pb2.SchemaInfo.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetTopic(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/eventbus.v1.PubSub/GetTopic',
            pubsub__api__pb2.TopicRequest.SerializeToString,
            pubsub__api__pb2.TopicInfo.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Publish(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/eventbus.v1.PubSub/Publish',
            pubsub__api__pb2.PublishRequest.SerializeToString,
            pubsub__api__pb2.PublishResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def PublishStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/eventbus.v1.PubSub/PublishStream',
            pubsub__api__pb2.PublishRequest.SerializeToString,
            pubsub__api__pb2.PublishResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
